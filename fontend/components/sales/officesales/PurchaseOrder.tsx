'use client';

import {useEffect, useState, useCallback, useRef} from 'react';
import {useSession} from 'next-auth/react';
import {useRouter, useSearchParams} from 'next/navigation';
import {
    Table,
    TableHeader,
    TableColumn,
    TableBody,
    TableRow,
    TableCell,
    Tabs,
    Tab,
    Button,
    Spinner,
    Pagination,
    Card,
    CardBody,
    CardHeader,
    Input
} from "@heroui/react";
import EditFromOrder from './EditFromOrder';
import {useOrderStore} from './orderStore';

const statusMap: { [key: string]: string } = {
    all: 'T·∫•t c·∫£ ƒë∆°n h√†ng',
    Pending: 'Ch·ªù thanh to√°n',
    Paid: 'ƒê√£ thanh to√°n',
};

interface Order {
    orderId: number;
    orderCode: string;
    customerName?: string;
    phoneNumber?: string;
    orderStatus: string;
    finalAmount: number;
    subTotalAmount: number;
    discountAmount: number;
}

export default function PurchaseOrder() {
    const {data: session} = useSession();
    const router = useRouter();
    const searchParams = useSearchParams();

    // ƒê·ªãnh nghƒ©a gi·ªõi h·∫°n t·∫°o h√≥a ƒë∆°n m·ªõi
    const MAX_ORDER_CREATION_LIMIT = 5;

    // State cho toast message - gi·ªù ch·ªâ c√≥ error ho·∫∑c warning
    const [toastMessage, setToastMessage] = useState<{ message: string; type: 'error' | 'warning' } | null>(null);

    // State cho t√¨m ki·∫øm - ch·ªâ c·∫ßn 1 √¥ t√¨m ki·∫øm th·ªëng nh·∫•t
    const [searchTerm, setSearchTerm] = useState('');
    const [isSearching, setIsSearching] = useState(false);
    const [searchResults, setSearchResults] = useState<Order[]>([]);
    const [isSearchMode, setIsSearchMode] = useState(false);
    const [isPendingSearch, setIsPendingSearch] = useState(false); // Tr·∫°ng th√°i ch·ªù t√¨m ki·∫øm

    // Ref cho debounce timer
    const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);

    // Zustand store - T·∫•t c·∫£ state v√† logic t·ª´ store
    const {
        // States
        orders,
        loading,
        error,
        isCreating,
        page,
        totalPages,
        activeTab,
        isEditMode,

        // Actions
        setPage,
        setActiveTab,
        resetError,

        // API Actions
        fetchOrders,
        createOrder,
        deleteOrder,
        openEditOrder,
    } = useOrderStore();

    // Extract complex expressions for dependency arrays
    const sessionAccessToken = session?.accessToken;

    // Handler ƒë·ªÉ xem chi ti·∫øt ƒë∆°n h√†ng
    const handleViewDetails = useCallback((order: Order) => {
        openEditOrder(order as Parameters<typeof openEditOrder>[0]);
    }, [openEditOrder]);

    // Auto-fetch orders when dependencies change
    useEffect(() => {
        if (sessionAccessToken) {
            fetchOrders(session);
        }
    }, [session, page, activeTab, fetchOrders, sessionAccessToken]);

    // T·ª± ƒë·ªông m·ªü order khi c√≥ query parameter viewOrder
    useEffect(() => {
        if (!searchParams) return;

        const viewOrderCode = searchParams.get('viewOrder');
        if (viewOrderCode && orders.length > 0 && !isEditMode) {
            const orderToOpen = orders.find(order => order.orderCode === viewOrderCode);
            if (orderToOpen) {
                console.log('üéØ Auto-opening order from URL:', viewOrderCode);
                handleViewDetails(orderToOpen);
                // X√≥a query parameter sau khi ƒë√£ m·ªü order
                router.replace('/staff/officesales');
            }
        }
    }, [searchParams, orders, isEditMode, router, handleViewDetails]);

    // Function to show a toast message (only warning/error now)
    const showToast = useCallback((message: string, type: 'error' | 'warning' = 'warning') => {
        setToastMessage({message, type});
        const timer = setTimeout(() => {
            setToastMessage(null);
        }, 5000); // Hide after 5 seconds
        return () => clearTimeout(timer);
    }, []);

    // Handler cho t√¨m ki·∫øm th√¥ng minh - t·ª± ƒë·ªông ph√°t hi·ªán lo·∫°i d·ªØ li·ªáu
    const handleSearch = useCallback(async () => {
        if (!session?.accessToken) return;

        const term = searchTerm.trim();

        // Ki·ªÉm tra c√≥ d·ªØ li·ªáu kh√¥ng
        if (!term) {
            showToast('Vui l√≤ng nh·∫≠p th√¥ng tin ƒë·ªÉ t√¨m ki·∫øm', 'warning');
            return;
        }

        setIsSearching(true);
        try {
            const url = new URL('http://localhost:8080/api/orders/search/simple');
            url.searchParams.append('page', '0');
            url.searchParams.append('size', '50'); // TƒÉng size ƒë·ªÉ hi·ªÉn th·ªã nhi·ªÅu k·∫øt qu·∫£ h∆°n

            // T√¨m ki·∫øm th√¥ng minh - g·ª≠i c√πng m·ªôt gi√° tr·ªã cho c·∫£ 3 tr∆∞·ªùng
            // Backend s·∫Ω t·ª± ƒë·ªông t√¨m trong t·∫•t c·∫£ c√°c tr∆∞·ªùng
            url.searchParams.append('orderCode', term);
            url.searchParams.append('customerName', term);
            url.searchParams.append('phoneNumber', term);

            const res = await fetch(url.toString(), {
                headers: {
                    'Authorization': `Bearer ${session.accessToken}`,
                },
            });

            if (!res.ok) {
                throw new Error(`L·ªói ${res.status}: Kh√¥ng th·ªÉ t√¨m ki·∫øm ƒë∆°n h√†ng.`);
            }

            const responseData = await res.json();
            const results = responseData?.data?.content || [];

            setSearchResults(results);
            setIsSearchMode(true);

            if (results.length === 0) {
                showToast('Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng n√†o ph√π h·ª£p v·ªõi th√¥ng tin t√¨m ki·∫øm', 'warning');
            }
        } catch (err: unknown) {
            const errorMessage = err instanceof Error ? err.message : 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi t√¨m ki·∫øm';
            showToast(errorMessage, 'error');
        } finally {
            setIsSearching(false);
        }
    }, [searchTerm, session, showToast]);

    // Handler ƒë·ªÉ x√≥a k·∫øt qu·∫£ t√¨m ki·∫øm v√† quay l·∫°i danh s√°ch ban ƒë·∫ßu
    const handleClearSearch = useCallback(() => {
        // Clear debounce timer
        if (debounceTimerRef.current) {
            clearTimeout(debounceTimerRef.current);
            debounceTimerRef.current = null;
        }

        setSearchTerm('');
        setSearchResults([]);
        setIsSearchMode(false);
        setIsPendingSearch(false);

        // T·∫£i l·∫°i danh s√°ch ƒë∆°n h√†ng ban ƒë·∫ßu
        if (session?.accessToken) {
            fetchOrders(session);
        }
    }, [session, fetchOrders]);

    // Handler ƒë·ªÉ l√†m m·ªõi to√†n b·ªô trang (reset state)
    const handleRefresh = useCallback(() => {
        // Clear debounce timer
        if (debounceTimerRef.current) {
            clearTimeout(debounceTimerRef.current);
            debounceTimerRef.current = null;
        }

        // Reset search state
        setSearchTerm('');
        setSearchResults([]);
        setIsSearchMode(false);
        setIsSearching(false);
        setIsPendingSearch(false);

        // Reset toast message
        setToastMessage(null);

        // Fetch l·∫°i d·ªØ li·ªáu t·ª´ ƒë·∫ßu
        if (session?.accessToken) {
            fetchOrders(session);
        }
    }, [session, fetchOrders]);

    // Handler cho ph√≠m Enter
    const handleKeyPress = useCallback((e: React.KeyboardEvent) => {
        if (e.key === 'Enter' && !isSearching) {
            // Clear debounce timer v√† t√¨m ki·∫øm ngay l·∫≠p t·ª©c
            if (debounceTimerRef.current) {
                clearTimeout(debounceTimerRef.current);
                debounceTimerRef.current = null;
            }
            handleSearch();
        }
    }, [handleSearch, isSearching]);

    // Auto search v·ªõi debounce
    useEffect(() => {
        // Clear timer c≈©
        if (debounceTimerRef.current) {
            clearTimeout(debounceTimerRef.current);
        }

        const term = searchTerm.trim();

        // N·∫øu kh√¥ng c√≥ g√¨ ƒë·ªÉ t√¨m, reset v·ªÅ danh s√°ch ban ƒë·∫ßu
        if (!term) {
            setIsPendingSearch(false);
            if (isSearchMode) {
                setSearchResults([]);
                setIsSearchMode(false);
                // T·∫£i l·∫°i danh s√°ch ban ƒë·∫ßu
                if (session?.accessToken) {
                    fetchOrders(session);
                }
            }
            return;
        }

        // Hi·ªÉn th·ªã tr·∫°ng th√°i ch·ªù t√¨m ki·∫øm
        setIsPendingSearch(true);

        // N·∫øu c√≥ t·ª´ kh√≥a t√¨m ki·∫øm, set timer ƒë·ªÉ t·ª± ƒë·ªông t√¨m
        debounceTimerRef.current = setTimeout(() => {
            setIsPendingSearch(false);
            handleSearch();
        }, 800); // ƒê·ªô tr·ªÖ 800ms - ph√π h·ª£p cho UX

        // Cleanup function
        return () => {
            if (debounceTimerRef.current) {
                clearTimeout(debounceTimerRef.current);
            }
        };
    }, [searchTerm, isSearchMode, session, fetchOrders, handleSearch]);

    // Handlers using store functions
    const handleTabSelectionChange = (key: string | number) => {
        setActiveTab(key);
    };

    const handleCreateOrder = async () => {
        // --- MODIFICATION START ---
        // Filter for "Pending" orders only
        const pendingOrders = orders.filter(order => order.orderStatus === 'Pending');

        // Check if the maximum order creation limit has been reached for PENDING orders
        if (pendingOrders.length >= MAX_ORDER_CREATION_LIMIT) {
            showToast(`B·∫°n ch·ªâ ƒë∆∞·ª£c ph√©p t·∫°o t·ªëi ƒëa ${MAX_ORDER_CREATION_LIMIT} ƒë∆°n h√†ng ·ªü tr·∫°ng th√°i 'Ch·ªù thanh to√°n'. Vui l√≤ng ho√†n t·∫•t ho·∫∑c x√≥a c√°c ƒë∆°n h√†ng ƒëang ch·ªù tr∆∞·ªõc khi t·∫°o m·ªõi.`, 'warning');
            return; // Stop the function execution
        }
        // --- MODIFICATION END ---

        // If limits are not met, proceed to create the order
        // No success toast for creation as requested.
        await createOrder(session);
    };

    const handleDeleteOrder = async (orderId: number) => {
        await deleteOrder(orderId, session);
        // No success toast for deletion as requested.
    };

    // Render table content v·ªõi h·ªó tr·ª£ t√¨m ki·∫øm
    const renderTableContent = () => {
        // Hi·ªÉn th·ªã loading cho t√¨m ki·∫øm
        if (isSearching) {
            return <div className="flex justify-center items-center h-64"><Spinner label="ƒêang t√¨m ki·∫øm..."/></div>;
        }

        if (loading && !isSearchMode) {
            return <div className="flex justify-center items-center h-64"><Spinner label="ƒêang t·∫£i..."/></div>;
        }

        if (error && !isSearchMode) {
            return <div className="text-center text-red-500 p-4 h-64">{error}</div>;
        }

        // S·ª≠ d·ª•ng k·∫øt qu·∫£ t√¨m ki·∫øm n·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô t√¨m ki·∫øm, ng∆∞·ª£c l·∫°i d√πng orders t·ª´ store
        const currentOrders = isSearchMode ? searchResults : orders;

        if (currentOrders.length === 0) {
            return (
                <div className="text-center text-gray-500 p-8 h-64 flex flex-col items-center justify-center">
                    <p className="text-lg font-medium mb-2">
                        {isSearchMode ? 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng ph√π h·ª£p' : 'Ch∆∞a c√≥ ƒë∆°n h√†ng t·∫°i qu·∫ßy n√†o'}
                    </p>
                    <p className="text-sm">
                        {isSearchMode ? 'Th·ª≠ thay ƒë·ªïi t·ª´ kh√≥a t√¨m ki·∫øm' : 'T·∫°o ƒë∆°n h√†ng m·ªõi ƒë·ªÉ b·∫Øt ƒë·∫ßu b√°n h√†ng tr·ª±c ti·∫øp'}
                    </p>
                </div>
            );
        }

        return (
            <Table
                aria-label="B·∫£ng danh s√°ch ƒë∆°n h√†ng"
                bottomContent={
                    // ·∫®n pagination khi ƒëang ·ªü ch·∫ø ƒë·ªô t√¨m ki·∫øm
                    !isSearchMode && totalPages > 1 ? (
                        <div className="flex w-full justify-center">
                            <Pagination
                                isCompact
                                showControls
                                showShadow
                                color="primary"
                                page={page}
                                total={totalPages}
                                onChange={setPage}
                            />
                        </div>
                    ) : null
                }
            >
                <TableHeader>
                    <TableColumn>M√É ƒê∆†N H√ÄNG</TableColumn>
                    <TableColumn>KH√ÅCH H√ÄNG</TableColumn>
                    <TableColumn>S·ªê ƒêI·ªÜN THO·∫†I</TableColumn>
                    <TableColumn>TR·∫†NG TH√ÅI</TableColumn>
                    <TableColumn className="text-right">T·ªîNG TI·ªÄN</TableColumn>
                    <TableColumn>H√ÄNH ƒê·ªòNG</TableColumn>
                </TableHeader>
                <TableBody emptyContent={" Kh√¥ng c√≥ ƒë∆°n h√†ng t·∫°i qu·∫ßy n√†o."}>
                    {currentOrders.map((order) => (
                        <TableRow key={order.orderId}>
                            <TableCell>{order.orderCode}</TableCell>
                            <TableCell>{order.customerName || 'Kh√°ch l·∫ª'}</TableCell>
                            <TableCell>{order.phoneNumber || 'Kh√¥ng c√≥ th√¥ng tin'}</TableCell>
                            <TableCell>
                                <div className="flex flex-col gap-1">
                                    <span
                                        className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${order.orderStatus === 'Paid' ? 'bg-green-100 text-green-800' :
                                            'bg-gray-100 text-gray-800'
                                        }`}>
                                        {order.orderStatus === 'Paid' ? '' : ''}
                                        {' '}
                                        {statusMap[order.orderStatus as keyof typeof statusMap] || order.orderStatus}
                                    </span>
                                </div>
                            </TableCell>
                            <TableCell
                                className="text-right">{order.finalAmount.toLocaleString('vi-VN')} VND</TableCell>
                            <TableCell className="flex gap-2">
                                <Button
                                    size="sm"
                                    color="primary"
                                    variant="flat"
                                    onPress={() => handleViewDetails(order)}
                                >
                                    {order.orderStatus === 'Paid' ? ' Xem chi ti·∫øt' : ' X·ª≠ l√Ω ƒë∆°n h√†ng'}
                                </Button>
                                {order.orderStatus != 'Paid' && <Button
                                    size="sm"
                                    color="danger"
                                    variant="flat"
                                    onPress={() => handleDeleteOrder(order.orderId)}
                                >
                                    X√≥a
                                </Button>}
                            </TableCell>
                        </TableRow>
                    ))}
                </TableBody>
            </Table>
        )
    };

    // Conditional rendering based on store state
    if (isEditMode) {
        return <EditFromOrder/>;
    }

    return (
        <div className="flex w-full flex-col gap-4 p-4">
            {/* Toast Message Display */}
            {toastMessage && (
                <div className={`fixed top-4 right-4 z-50 p-4 pr-6 rounded-lg border-l-4 shadow-lg flex items-center gap-3 transform transition-transform duration-300 ease-out translate-x-0
                    ${toastMessage.type === 'error' ? 'bg-red-50 border-red-500 text-red-700' :
                    'bg-yellow-50 border-yellow-500 text-yellow-700'}`}
                >
                    <span className="text-xl">
                        {toastMessage.type === 'error' ? '‚ùå' : '‚ö†Ô∏è'}
                    </span>
                    <p className="font-semibold">{toastMessage.message}</p>
                    <Button
                        isIconOnly
                        variant="light"
                        size="sm"
                        onPress={() => setToastMessage(null)}
                        className="ml-auto text-current" // Use current text color for button icon
                    >
                        &times;
                    </Button>
                </div>
            )}

            <div className="flex justify-between items-center">
                <h1 className="text-2xl font-bold">Qu·∫£n l√Ω ƒê∆°n h√†ng</h1>
                <div className="flex gap-2">
                    <Button
                        variant="flat"
                        color="default"
                        onClick={handleRefresh}
                        disabled={isCreating || isSearching}
                        startContent={
                            <svg
                                className="w-4 h-4"
                                fill="none"
                                stroke="currentColor"
                                viewBox="0 0 24 24"
                            >
                                <path
                                    strokeLinecap="round"
                                    strokeLinejoin="round"
                                    strokeWidth={2}
                                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                                />
                            </svg>
                        }
                    >
                        L√†m m·ªõi
                    </Button>
                    <Button
                        color="primary"
                        onClick={handleCreateOrder}
                        disabled={isCreating}
                    >
                        {isCreating ? <Spinner color="white" size="sm"/> : "T·∫°o ƒê∆°n H√†ng M·ªõi"}
                    </Button>
                </div>
            </div>

            {/* Giao di·ªán t√¨m ki·∫øm */}
            <Card className="w-full">
                <CardHeader className="pb-3">
                    <div className="flex justify-between items-center w-full">
                        <h3 className="text-lg font-semibold">T√¨m ki·∫øm ƒë∆°n h√†ng</h3>
                        {isSearchMode && (
                            <Button
                                variant="flat"
                                color="warning"
                                size="sm"
                                onPress={handleClearSearch}
                                startContent={
                                    <svg
                                        className="w-4 h-4"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            strokeLinecap="round"
                                            strokeLinejoin="round"
                                            strokeWidth={2}
                                            d="M6 18L18 6M6 6l12 12"
                                        />
                                    </svg>
                                }
                            >
                                X√≥a t√¨m ki·∫øm
                            </Button>
                        )}
                    </div>
                </CardHeader>
                <CardBody className="pt-0">
                    <div className="flex flex-col gap-4">
                        <Input
                            label="T√¨m ki·∫øm ƒë∆°n h√†ng"
                            placeholder="Nh·∫≠p m√£ ƒë∆°n h√†ng, t√™n kh√°ch h√†ng ho·∫∑c s·ªë ƒëi·ªán tho·∫°i..."
                            value={searchTerm}
                            onValueChange={setSearchTerm}
                            onKeyDown={handleKeyPress}
                            variant="bordered"
                            size="lg"
                            startContent={
                                isPendingSearch ? (
                                    <Spinner size="sm" color="primary"/>
                                ) : (
                                    <svg
                                        className="w-5 h-5 text-gray-400"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                    >
                                        <path
                                            strokeLinecap="round"
                                            strokeLinejoin="round"
                                            strokeWidth={2}
                                            d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                                        />
                                    </svg>
                                )
                            }
                            // description={
                            //     isPendingSearch
                            //         ? "‚è≥ ƒêang chu·∫©n b·ªã t√¨m ki·∫øm..."
                            //         : "üöÄ T√¨m ki·∫øm t·ª± ƒë·ªông: H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông t√¨m ki·∫øm khi b·∫°n ng·ª´ng nh·∫≠p"
                            // }
                        />
                    </div>
                    {/* Hi·ªÉn th·ªã tr·∫°ng th√°i t√¨m ki·∫øm */}
                    {isSearching && (
                        <div className="flex items-center justify-center mt-3 p-2 bg-blue-50 rounded-lg">
                            <Spinner size="sm" color="primary"/>
                            <span className="ml-2 text-sm text-blue-700">ƒêang t√¨m ki·∫øm...</span>
                        </div>
                    )}

                    {/* N√∫t x√≥a n·ªôi dung ch·ªâ hi·ªÉn th·ªã khi c√≥ text */}
                    {searchTerm && (
                        <div className="flex justify-end mt-3">
                            <Button
                                variant="flat"
                                size="sm"
                                onPress={() => setSearchTerm('')}
                                disabled={isSearching}
                                startContent={
                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
                                              d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                }
                            >
                                X√≥a n·ªôi dung
                            </Button>
                        </div>
                    )}
                    {isSearchMode && (
                        <div className="mt-3 p-3 bg-blue-50 rounded-lg border border-blue-200">
                            <div className="flex items-center justify-between flex-wrap gap-2">
                                <p className="text-sm text-blue-700">
                                    üìã ƒêang hi·ªÉn th·ªã k·∫øt qu·∫£ t√¨m ki·∫øm cho: <span
                                    className="font-semibold">{searchTerm}</span> ({searchResults.length} ƒë∆°n h√†ng)
                                </p>
                                <p className="text-xs text-blue-600">
                                    üí° D√πng n√∫t L√†m m·ªõi ho·∫∑c X√≥a t√¨m ki·∫øm ƒë·ªÉ quay l·∫°i danh s√°ch ƒë·∫ßy ƒë·ªß
                                </p>
                            </div>
                        </div>
                    )}

                    {/* Th√¥ng b√°o khi kh√¥ng c√≥ k·∫øt qu·∫£ t√¨m ki·∫øm */}
                    {isSearchMode && searchResults.length === 0 && !isSearching && (
                        <div className="mt-3 p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                            <div className="flex items-start gap-3">
                                <svg className="w-5 h-5 text-yellow-600 mt-0.5 flex-shrink-0" fill="none"
                                     stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
                                          d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 15.5c-.77.833.192 2.5 1.732 2.5z"/>
                                </svg>
                                <div className="flex-1">
                                    <p className="text-sm font-medium text-yellow-800">
                                        Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng ph√π h·ª£p v·ªõi {searchTerm}
                                    </p>
                                    <p className="text-xs text-yellow-700 mt-1">
                                        ‚Ä¢ Th·ª≠ t√¨m ki·∫øm v·ªõi t·ª´ kh√≥a kh√°c<br/>
                                        ‚Ä¢ Ki·ªÉm tra l·∫°i ch√≠nh t·∫£<br/>
                                        ‚Ä¢ Nh·∫•n L√†m m·ªõi ƒë·ªÉ xem t·∫•t c·∫£ ƒë∆°n h√†ng
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}
                </CardBody>
            </Card>


            {/* Error handling from store */}
            {error && !isCreating && (
                <div className="p-4 mb-4 text-sm text-red-800 rounded-lg bg-red-50 dark:bg-gray-800 dark:text-red-400"
                     role="alert">
                    <span className="font-medium">L·ªói!</span> {error}
                    <Button
                        size="sm"
                        variant="light"
                        color="danger"
                        className="ml-2"
                        onPress={resetError}
                    >
                        ƒê√≥ng
                    </Button>
                </div>
            )}

            {/* Tabs with store state - ·∫®n khi ƒëang t√¨m ki·∫øm */}
            <div>
                {!isSearchMode ? (
                    <Tabs
                        aria-label="L·ªçc ƒë∆°n h√†ng theo tr·∫°ng th√°i"
                        items={Object.keys(statusMap).map(statusKey => ({
                            id: statusKey,
                            label: statusMap[statusKey as keyof typeof statusMap]
                        }))}
                        selectedKey={activeTab}
                        onSelectionChange={handleTabSelectionChange}
                        color="primary"
                        variant="underlined"
                    >
                        {(item) => (
                            <Tab key={item.id} title={item.label}>
                                {renderTableContent()}
                            </Tab>
                        )}
                    </Tabs>
                ) : (
                    // Hi·ªÉn th·ªã tr·ª±c ti·∫øp b·∫£ng khi ƒëang t√¨m ki·∫øm
                    <div className="mt-4">
                        {renderTableContent()}
                    </div>
                )}
            </div>
        </div>
    );
}